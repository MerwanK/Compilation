/*
 * generated by Xtext
 */
 
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.xtext.example.mydsl.myDsl.Programme
import org.xtext.example.mydsl.myDsl.Fonction
import org.xtext.example.mydsl.myDsl.Input
import org.xtext.example.mydsl.myDsl.Output
import org.xtext.example.mydsl.myDsl.Commandes
import org.xtext.example.mydsl.myDsl.Commande
import org.xtext.example.mydsl.myDsl.AffectVar
import org.xtext.example.mydsl.myDsl.While
import org.xtext.example.mydsl.myDsl.For
import org.xtext.example.mydsl.myDsl.If
import org.xtext.example.mydsl.myDsl.Foreach
import org.xtext.example.mydsl.myDsl.Vars
import org.xtext.example.mydsl.myDsl.Exprs
import org.xtext.example.mydsl.myDsl.Expr
import org.xtext.example.mydsl.myDsl.ExprSimple
import org.xtext.example.mydsl.myDsl.LExpr
import org.xtext.example.mydsl.myDsl.ExprAnd
import org.xtext.example.mydsl.myDsl.ExprOr
import org.xtext.example.mydsl.myDsl.ExprNot
import org.xtext.example.mydsl.myDsl.ExprEq
import org.xtext.example.mydsl.myDsl.Cons
import org.xtext.example.mydsl.myDsl.Liste
import org.xtext.example.mydsl.myDsl.Hd
import org.xtext.example.mydsl.myDsl.Tl
import org.xtext.example.mydsl.myDsl.SymboleEx
import org.xtext.example.mydsl.myDsl.ExprNotNot
import org.xtext.example.mydsl.myDsl.ExprNotDo
//import org.eclipse.emf.ecore.util.EcoreUtil
//import java.io.FileWriter
//import java.io.BufferedWriter
//import org.eclipse.xtext.resource.XtextResourceSet
//import java.io.File
//import org.xtext.example.mydsl.MyDslStandaloneSetup
//import org.eclipse.emf.common.util.URI
import tableSymboles.SymbolsTable
import code3adresses.CodeGenere

/* Last */
/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator implements IGenerator {
	
	private SymbolsTable tableSymboles;
	private String fonctionEnCours;
	private CodeGenere codeG;
	private int compteurRegistre;
	private int compteurCond;
	 
//	def public File generationCode3Adresses(String entree, String nameFile){
//	
//		val injector = new MyDslStandaloneSetup().createInjectorAndDoEMFRegistration();
//		val resourceSet = injector.getInstance(XtextResourceSet);
//		val uri = URI.createURI(entree);
//		val xtextResource = resourceSet.getResource(uri, true);
//		EcoreUtil.resolveAll(xtextResource);
//		val fstream = new FileWriter(nameFile);
// 		val buff = new BufferedWriter(fstream);
//  		for(p: xtextResource.allContents.toIterable.filter(Programme))
//			buff.write(p.compile().toString);
//  		buff.close();
//  		return new File(nameFile);
//	}
	
	//!!!!!!!!!!!!! NE PAS OUBLIEZ DE REMETTRE LES INIT DANS L'EXECUTABLE!!!!!!!!!!!!!!!!!!!!!!!!!!!
	override void doGenerate(Resource resource, IFileSystemAccess fsa){
		tableSymboles = new SymbolsTable();
		codeG = new CodeGenere();
		compteurCond = 0;
		compteurRegistre = 0;
		for(p: resource.allContents.toIterable.filter(Programme)){
			p.compile(); 
		}
	}
	
	def incrementeurRegistre(){
		compteurRegistre = compteurRegistre + 1;
		return ""; 
	}
	
	
	def compile(Programme p){
   		for(Fonction f: p.fonct){
   			f.compile();
   		}
   		System.out.println(tableSymboles.toString());
   		System.out.println(codeG.toString());
   }
		
   def compile(Fonction f){ 
		fonctionEnCours = f.symbole;
		tableSymboles.putFunction(f.symbole);
		f.in.compile();
		f.com.compile();
		f.out.compile();
	}	
   
   def compile(Input i){
   		tableSymboles.setInVariable(fonctionEnCours,i.var1);
   		codeG.addRead(i.var1);
   		for(String v :i.var2){
    		tableSymboles.setInVariable(fonctionEnCours,v);
    		codeG.addRead(v);
   		}
   }
   
   def compile(Output o){
   		tableSymboles.setOutVariable(fonctionEnCours,o.var1);
   		codeG.addWrite(o.var1);
   		for(String v :o.var2){
   			tableSymboles.setOutVariable(fonctionEnCours,v);
   			codeG.addWrite(v);	
   		}
   }
   
   
   def int compile(Commandes cos){
   		cos.com1.compile();
   		for(Commande v :cos.com2){  
   			v.compile();
   		}
   		return 0;
   }
   
   def compile(Commande co){
   		if(co.nop != null){
   			codeG.addNop();
   		}
   		if(co.affectVar != null){
   			co.affectVar.compile();
   		}
   		if(co.whileC != null){
   			co.whileC.compile();	
   		}
   		if(co.forC != null){
   			co.forC.compile();
   		}
   		if(co.ifC != null){
   			co.ifC.compile();
   		}
   		if(co.foreachC != null){
   			co.foreachC.compile();
   		}	
   	}
   
     
   def compile(AffectVar av){
  	 	av.var1.compile();
  	 	av.exp.compile();
   }
   
   def compile(While w){
   		codeG.addWhile("expr"+compteurCond);
   		w.exp2.compile();
   		compteurCond++;
   		w.com3.compile();
   }
      
   def compile(For f){
   		f.exp3.compile();
   		codeG.addFor("expr"+compteurCond);
   		compteurCond++;
   		f.com4.compile();
   }
   
   def compile(If ifc){
   		ifc.exp4.compile();
   		codeG.addIf("expr"+compteurCond);
   		ifc.com5.compile();
   		ifc.com6.compile();
   }
   
   def compile(Foreach fe){
   		fe.exp5.compile();
   		fe.exp6.compile();
   		fe.com7.compile();
   }
   
   def compile(Vars v){
   		tableSymboles.setVariable(fonctionEnCours,v.var2);
   		codeG.addAff(v.var2,"R"+compteurRegistre);
   		incrementeurRegistre();
   		for(String va :v.var3){
   			tableSymboles.setVariable(fonctionEnCours,va);
   			codeG.addAff(va,"R"+compteurRegistre);
   			incrementeurRegistre();
   		}
   }
   
   def compile(Exprs exps){
   		exps.exprS.compile();
   		for(Expr v :exps.exprS2){
   			 v.compile();
   		}
   }
   
   def int compile(Expr ex){
   		if(ex.expA != null){
   	 		ex.expA.compile();
   		}
  		if(ex.expS != null){
   			ex.expS.compile();  
   		}
   		return 0;
   		
   	}
   
   def compile(ExprSimple es){
   		if(es.vide != null){
   			
   		}
   		if(es.variable != null){
   			tableSymboles.setVariable(fonctionEnCours,es.variable);	
   		}
   		if(es.symbole != null){
   			tableSymboles.setSymbol(es.symbole);
   		}
   		if(es.cons != null){
   			es.cons.compile();
   		}
   		if(es.liste != null){
   			es.liste.compile();
   		}
   		if(es.hd != null){
   			es.hd.compile();
   		}
   		if(es.tl != null){
   			es.tl.compile();
   		}
   		if(es.symbolEx != null){
   			es.symbolEx.compile();
   		}
   }
   
   def compile(Cons ce){
   		ce.le1.compile();
   }
   
   def compile(Liste lie){
   		lie.le2.compile();
   }
   
   def compile(Hd h){
   		h.le3.compile();
   }
   
   def compile(Tl t){
   		t.le4.compile();
   }
   
   def compile(SymboleEx sex){
   		sex.le5.compile();
   }
   
   def compile(ExprAnd ea){
   		ea.expO.compile();
   		for(ExprOr v :ea.expO2){
   			v.compile();
   		}
   }
   
   def compile(ExprOr eo){
   		eo.expN.compile();
   		for(ExprNot v:eo.expN2){
   			v.compile();
   		}
   }
   
   def compile(ExprNot en){
		if(en.exprNotNot != null){
			en.exprNotNot.compile();
		}
		if(en.exprNotDo != null){
			en.exprNotDo.compile();
		}
	}
	
   def compile(ExprNotNot enn){
   		enn.expEq1.compile();
   }
   	
   def compile(ExprNotDo end){
   		end.expEq2.compile();
   }
   
   def compile(ExprEq eeq){
		eeq.expS1.compile();
		eeq.expS2.compile(); 
		eeq.expR.compile();
   }
   
   def compile(LExpr a){
   for(Expr v: a.expLe)
   		v.compile(); 
   }

   
}